import{S as Uf,i as Vf,s as zf,C as Ed,w as Bf,x as Yf,y as Kf,z as Xf,A as Lf,q as Zf,o as Qf,B as ev,r as tv,Y as $f,e as l,t as o,k as c,c as s,a as i,h as r,d as n,m as h,b as d,X as qf,g as R,H as e}from"../../chunks/vendor-da4388d4.js";import{T as av}from"../../chunks/TalkLayout-d81f0c42.js";import"../../chunks/stores-1fad7c36.js";import"../../chunks/ldjson-b0805387.js";/* empty css                                */var ov="https://lihautan.com/_app/assets/hero-twitter-f463c0ae.jpg";function rv(fe){let u,E,y,U,f,w,J,V,rr,nr,_,_d,Io,W,kt,z,lr,sr,S,Sd,No,F,Tt,B,ir,cr,Y,hr,ve,dr,pr,Ho,t,Pt,K,ur,fr,X,vr,Ot,mr,wr,gr,Ct,br,yr,xt,Er,_r,At,Sr,kr,Dt,jt,Tr,Pr,Z,Or,me,Cr,xr,Ar,Mt,Dr,jr,Q,Mr,we,Ir,Nr,Hr,It,Rr,Jr,Nt,Wr,Fr,ee,Lr,Ht,$r,qr,Gr,te,Ur,ge,Vr,zr,Br,Rt,Yr,Kr,Jt,Xr,Zr,D,Qr,Wt,en,tn,Ft,an,on,rn,Lt,nn,ln,$t,sn,cn,qt,hn,dn,Gt,pn,un,Ut,fn,vn,Vt,mn,wn,ae,gn,be,bn,yn,En,zt,_n,Sn,oe,kn,ye,Tn,Pn,On,Bt,Cn,xn,Ee,Yt,An,Dn,jn,g,Mn,_e,In,Nn,Se,Hn,Rn,ke,Jn,Wn,Te,Fn,Ln,Pe,$n,qn,Gn,Kt,Un,Vn,Xt,zn,Bn,Oe,Yn,Zt,Kn,Xn,Qt,ea,Zn,Qn,ta,el,tl,aa,al,ol,oa,rl,nl,ra,ll,sl,na,il,cl,la,hl,dl,sa,pl,ul,ia,ca,fl,vl,ha,ml,wl,re,gl,da,bl,yl,El,pa,_l,Sl,ua,kl,Tl,fa,Pl,Ol,va,Cl,xl,ma,wa,Al,Dl,Ce,jl,ga,Ml,Il,ba,Nl,Hl,ya,Ea,Rl,Jl,O,Wl,_a,xe,Fl,Ll,Sa,Ae,$l,ql,ka,De,Gl,Ul,Vl,ne,zl,je,Bl,Yl,Kl,C,Xl,Me,Zl,Ql,Ie,es,ts,Ne,as,os,rs,Ta,ns,ls,Pa,ss,is,Oa,cs,hs,Ca,ds,ps,xa,us,fs,Aa,vs,ms,Da,ws,gs,ja,bs,ys,Ma,Es,_s,Ia,Ss,ks,Na,Ts,Ps,Ha,Os,Cs,Ra,xs,As,Ja,Ds,js,Wa,Ms,Is,Fa,Ns,Hs,La,Rs,Js,$a,Ws,Fs,qa,Ls,$s,Ga,qs,Gs,Ua,Us,Vs,Va,zs,Bs,za,Ys,Ks,Ba,Xs,Zs,Ya,Qs,ei,Ka,ti,ai,Xa,oi,ri,Za,ni,li,Qa,si,ii,eo,ci,hi,to,di,pi,ao,ui,fi,le,vi,He,mi,wi,gi,oo,bi,yi,ro,Ei,_i,se,Si,Re,ki,Ti,Pi,no,Oi,Ci,j,xi,Je,Ai,Di,We,ji,Mi,Ii,M,Ni,Fe,Hi,Ri,Le,Ji,Wi,Fi,b,Li,$e,$i,qi,qe,Gi,Ui,Ge,Vi,zi,Ue,Bi,Yi,Ve,Ki,Xi,Zi,lo,Qi,ec,I,tc,ze,ac,oc,Be,rc,nc,lc,so,sc,ic,io,cc,hc,co,dc,pc,ho,uc,fc,po,vc,mc,uo,wc,gc,fo,bc,yc,vo,Ec,_c,mo,Sc,kc,v,Tc,Ye,Pc,Oc,Ke,Cc,xc,Xe,Ac,Dc,Ze,jc,Mc,Qe,Ic,Nc,et,Hc,Rc,tt,Jc,Wc,at,Fc,Lc,$c,wo,qc,Gc,x,Uc,ot,Vc,zc,rt,Bc,Yc,nt,Kc,Xc,Zc,go,Qc,eh,bo,th,ah,A,oh,lt,rh,nh,st,lh,sh,it,ih,ch,hh,yo,dh,ph,N,uh,ct,fh,vh,ht,mh,wh,gh,Eo,bh,yh,H,Eh,dt,_h,Sh,pt,kh,Th,Ph,_o,Oh,Ch,ie,xh,ut,Ah,Dh,jh,ce,Mh,ft,Ih,Nh,Hh,So,Rh,Jh,he,Wh,ko,Fh,Lh,$h,de,qh,vt,Gh,Uh,Vh,To,zh,Bh,Po,Yh,Kh,Oo,Xh,Zh,pe,Qh,mt,ed,td,ad,ue,od,wt,rd,nd,ld,Co,sd,id,xo,cd,hd,Ao,dd,pd,Do,ud,fd,jo,vd,md,Mo,wd;return{c(){u=l("section"),E=l("h2"),y=l("a"),U=o("Recorded talk"),f=c(),w=l("section"),J=l("h3"),V=l("a"),rr=o("CityJS Conference 2020"),nr=c(),_=l("iframe"),Io=c(),W=l("section"),kt=l("h3"),z=l("a"),lr=o("MMT Tech Meetup - Sept 2020"),sr=c(),S=l("iframe"),No=c(),F=l("section"),Tt=l("h2"),B=l("a"),ir=o("Slides"),cr=c(),Y=l("p"),hr=o("["),ve=l("a"),dr=o("Link to slides"),pr=o("] (Left arrow and right arrow to navigate)"),Ho=c(),t=l("section"),Pt=l("h2"),K=l("a"),ur=o("Script"),fr=c(),X=l("p"),vr=o("Modern web frameworks allow us to describe our "),Ot=l("strong"),mr=o("UI"),wr=o(" declaratively, as a function of state, of the application."),gr=c(),Ct=l("p"),br=o("The function can be written in a form of template, or template-like syntax, which describes exactly how the view should look like, in all possible states."),yr=c(),xt=l("p"),Er=o("When the state change, the view should change as well."),_r=c(),At=l("p"),Sr=o("We don't need to describe how one view transition to another view. We don't need to describe what elements to be added, removed or modified."),kr=c(),Dt=l("p"),jt=l("strong"),Tr=o("Modern Web Framework do that for us."),Pr=c(),Z=l("p"),Or=o("The "),me=l("code"),Cr=o("framework_magic"),xr=o(" takes in 2 subsequent views and figure out how to transition from 1 to another."),Ar=c(),Mt=l("p"),Dr=o("Modern web frameworks like React and Vue do that using a technique called a virtual DOM."),jr=c(),Q=l("p"),Mr=o("To handle all the possible scenarios, this "),we=l("code"),Ir=o("framework_magic"),Nr=o(" could be very huge in code size, and it is independent of the application it is supporting."),Hr=c(),It=l("p"),Rr=o("For react is 40kb gzipped and vue2 is 23kb gzipped, vue3 is 10kb."),Jr=c(),Nt=l("p"),Wr=o("and if your application is simple, it could disproportionately small in terms of code size relative to the framework library, which is shown in the gray portion of the chart."),Fr=c(),ee=l("p"),Lr=o("However, this doesnt have to be, "),Ht=l("strong"),$r=o("the only way"),qr=o(" of doing things."),Gr=c(),te=l("p"),Ur=o("What if we could shift all of the work done in the "),ge=l("code"),Vr=o("framework_magic"),zr=o(" from runtime to build time?"),Br=c(),Rt=l("p"),Yr=o("We can analyse the code and figure out all the possible states and views, and the possible transitions between them, and generate just enough code to do just that?"),Kr=c(),Jt=l("p"),Xr=o("And that's the core idea of Svelte."),Zr=c(),D=l("p"),Qr=o("The Svelte compiler compiles the Svelte code into "),Wt=l("strong"),en=o("optimised"),tn=o(" JavaScript code that "),Ft=l("strong"),an=o("grows linearly"),on=o(" along with your application code."),rn=c(),Lt=l("p"),nn=o("and today we are going to look into the Svelte compiler."),ln=c(),$t=l("p"),sn=o("Don't worry if you are not familiar with Svelte / compiler, I'll try my best to avoid the jargons and explain the general idea of the process."),cn=c(),qt=l("p"),hn=o("My name is Tan Li Hau, I am a software engineer at Shopee. Shopee is a e-commerce platform in South east asia that is based in Singapore."),dn=c(),Gt=l("p"),pn=o("I grew up in a lovely town called penang in malaysia, which has the best street food in malaysia, such as char koay teow, stir-fry flat rice noodles; rojak, a eclectic fruit salad with palm sugar, peanuts and chilli dressing, and dont get me started with food. Hopefully you guys can come visit Malaysia after this coronavirus pandemic is over."),un=c(),Ut=l("p"),fn=o("last but not the least, Im one of the maintainers of svelte"),vn=c(),Vt=l("p"),mn=o("Before we start talking about compilers, for the benefit of those who havn't have a chance to look into Svelte, lets take a look at how a svelte component looks like."),wn=c(),ae=l("p"),gn=o("a svelte component is written in a file with a "),be=l("code"),bn=o(".svelte"),yn=o(" extension. Each file describes 1 svelte  component."),En=c(),zt=l("p"),_n=o("You can add 1 script tag to the component. The script tag allows you to define variable, just like how you would in any javascript code,  and you can reference the variables in your html template, with a curly bracket."),Sn=c(),oe=l("p"),kn=o("To add event listener, you use a "),ye=l("code"),Tn=o("on:"),Pn=o(" directive, and you can update the variable just like this, and it will automatically updated in your DOM."),On=c(),Bt=l("p"),Cn=o("You can add a style tag and write some css to style your component. What's cool about it is that, the css is scoped within the component. so when i say button, background: red, only the button written in this component file has the background red. not the child component, not the parent component. just this component."),xn=c(),Ee=l("p"),Yt=l("strong"),An=o("now"),Dn=o(", here is one of the most powerful, and somewhat controversial feature of svelte, reactive declarations."),jn=c(),g=l("p"),Mn=o("here you have a "),_e=l("code"),In=o("double = count * 2"),Nn=o(", with a dollar + colon sign in front of the statement. this means that the variable "),Se=l("code"),Hn=o("double"),Rn=o(" is always 2 times of "),ke=l("code"),Jn=o("count"),Wn=o(", whenever the value of "),Te=l("code"),Fn=o("count"),Ln=o(" has changed, the value of "),Pe=l("code"),$n=o("double"),qn=o(" will update as well."),Gn=c(),Kt=l("p"),Un=o("This definitely feels weird in the beginning, but the more you use it, you'll ask yourself why didn't we have this earlier."),Vn=c(),Xt=l("p"),zn=o("So, here we have 1 big red button, and a text of multiply equation as a Svelte component."),Bn=c(),Oe=l("p"),Yn=o("I am gonna pause here for a moment, and ask you this question, "),Zt=l("strong"),Kn=o("how would you implement this, if you are not allowed to use any framework and you have to write it in Vanilla JavaScript?"),Xn=c(),Qt=l("p"),ea=l("em"),Zn=o("(pause)"),Qn=c(),ta=l("p"),el=o("So, firstly we are going to start with the variable declaration."),tl=c(),aa=l("p"),al=o("Next we create the text with document.createTextNode, and insert it to the parent"),ol=c(),oa=l("p"),rl=o("Next we create the button, change the text, add event listener and insert it to the parent."),nl=c(),ra=l("p"),ll=o("To update the text when the count is updated, we create an update function, where we update the value of double and update the content of the text."),sl=c(),na=l("p"),il=o("Finally for the style tag, we create a style tag, set the content and insert into the head."),cl=c(),la=l("p"),hl=o("To make sure that the button only targets this button that we just created, we add a class to the button."),dl=c(),sa=l("p"),pl=o("Here the class name is random, but it could be generated based on the hash of the style code, so you get consistent class name."),ul=c(),ia=l("p"),ca=l("em"),fl=o("(CLICK TO VIEW JS OUTPUT)"),vl=c(),ha=l("p"),ml=o("In fact if you take a look at the svelte generated JS output, it is very similar to the code we just wrote."),wl=c(),re=l("p"),gl=o("So, this is just the code you need to "),da=l("strong"),bl=o("create a button and a text"),yl=o(". You don't need 40KB Virtual DOM library to recreate the same component."),El=c(),pa=l("p"),_l=o("Of course, you don't have to write all of these yourself."),Sl=c(),ua=l("p"),kl=o("The Svelte compiler will do it for you. It will analyse the code above, and generate the code below for you."),Tl=c(),fa=l("p"),Pl=o('And now, if you try to choose "SSR" as the generated output, you can see now Svelte generates a function that returns a string composed using template literals.'),Ol=c(),va=l("p"),Cl=o("This is a few orders more performant than generating a tree object and serialising them into a HTML string."),xl=c(),ma=l("p"),wa=l("em"),Al=o("(DONT MOVE)"),Dl=c(),Ce=l("p"),jl=o("So, Let's take a few more examples of the Svelte syntax, and along the way, I hope you ask yourself this question, "),ga=l("strong"),Ml=o('"how do i convert this / write this in plain JavaScript?"'),Il=c(),ba=l("p"),Nl=o("and don't worry, you can find this repl on the svelte website. and you can compare the input and the js output anyway you want."),Hl=c(),ya=l("p"),Ea=l("em"),Rl=o("(OKAY NOW MOVE)"),Jl=c(),O=l("p"),Wl=o("To express logics within the template, Svelte provides logic block, such as "),_a=l("strong"),xe=l("code"),Fl=o("{#if}"),Ll=o(", "),Sa=l("strong"),Ae=l("code"),$l=o("{#await}"),ql=o(", and "),ka=l("strong"),De=l("code"),Gl=o("{#each}"),Ul=o("."),Vl=c(),ne=l("p"),zl=o("To reduce the boilerplate code for binding a variable to an input, Svelte provides the "),je=l("code"),Bl=o("bind:"),Yl=o(" directive."),Kl=c(),C=l("p"),Xl=o("To provide transition for elements coming into or out of the DOM, Svelte provides the "),Me=l("code"),Zl=o("transition"),Ql=o(", "),Ie=l("code"),es=o("in"),ts=o(" and "),Ne=l("code"),as=o("out"),os=o(" directive."),rs=c(),Ta=l("p"),ns=o("To compose Components, Svelte provides slots and templates similar to the Web Component APIs."),ls=c(),Pa=l("p"),ss=o("There's so much I would like to share here, but I have to segue into the Svelte compiler, because that's the main topic of today's talk."),is=c(),Oa=l("p"),cs=o("Now, finally, let's take a look at the Svelte compiler."),hs=c(),Ca=l("p"),ds=o("So, how does a compiler works?"),ps=c(),xa=l("p"),us=o("A compiler first reads through your code, and break it down into smaller pieces, called tokens."),fs=c(),Aa=l("p"),vs=o("The compiler then goes through this list of tokens and arrange them into a tree structure, according to the grammar of the language. The tree structure is what a compiler call \u201CAbstract syntax tree\u201D or AST for short."),ms=c(),Da=l("p"),ws=o("An AST is a tree representation of the input code."),gs=c(),ja=l("p"),bs=o(`And what the compiler sometimes do, is to analyse and apply transformation to the AST.
Using tree traversal algorithms, such as depth first search`),ys=c(),Ma=l("p"),Es=o("And finally, the compiler generates a code output based on the final AST."),_s=c(),Ia=l("p"),Ss=o("In summary, a generic compilation process involves parsing the code to an AST, doing analysis, optimsiation or transformation on the AST, and then generate code out from the AST."),ks=c(),Na=l("p"),Ts=o("Finally, let's take a look how Svelte compiler works."),Ps=c(),Ha=l("p"),Os=o("Svelte parses the Svelte code into AST"),Cs=c(),Ra=l("p"),xs=o("Svelte then analyses the AST, which we will explore in detailed later."),As=c(),Ja=l("p"),Ds=o(`With the analysis, Svelte generates JavaScript code depending on the compile target, whether it's for SSR or it's for the browser.
Finally, js and css is generated, and can be written into a file or be consumed by your build process.`),js=c(),Wa=l("p"),Ms=o("So lets start from the beginning, the parsing."),Is=c(),Fa=l("p"),Ns=o("Here is a Svelte component that we are going to use throughout this talk."),Hs=c(),La=l("p"),Rs=o("Svelte, implements its own parser"),Js=c(),$a=l("p"),Ws=o("That parses the html syntax, as well as logic blocks, like each, if, and await"),Fs=c(),qa=l("p"),Ls=o(`Because js is a fairly complex language, whenever svelte encounters a script tag, or a curly brackets, it will hand it over to acorn, a lightweight JavaScript parser, to parse the JS content.
The same thing goes with css as well. svelte uses css-tree to parse CSS content in between the style tag.`),$s=c(),Ga=l("p"),qs=o("So, through the process, the svelte code is broken down into tokens, and is arranged into the Svelte AST."),Gs=c(),Ua=l("p"),Us=o("If you interested to see how the Svelte AST looks like, you can check them out at ASTExplorer.net."),Vs=c(),Va=l("p"),zs=o("The next step is to analyse the AST."),Bs=c(),za=l("p"),Ys=o("Here, our code is already in AST, BUT to help visualise the process, i'm going to show you the original code."),Ks=c(),Ba=l("p"),Xs=o("The first thing Svelte do is to traverse through the script AST."),Zs=c(),Ya=l("p"),Qs=o("Whenever it encounters a variable, in this case, count, it will record down the variable name."),ei=c(),Ka=l("p"),ti=o("here we record values and double."),ai=c(),Xa=l("p"),oi=o('the "double" here, in this svelte code is a reactive declared variable. but to vanilla JavaScript, we are assigning value to this variable "double", which is not declared anywhere.'),ri=c(),Za=l("p"),ni=o('in strict mode, this is a "assignment to undeclared variable" error.'),li=c(),Qa=l("p"),si=o('Svelte marks the variable, "double", as "injected", so the declaration of the variable will be injected later. other examples of injected variables are svelte magic global, such as $$props, or a $ prefix of a store variable.'),ii=c(),eo=l("p"),ci=o('here we encounter "count" again, this time its being referenced, instead of being assinged to a value, and it is used to compute the value of double. so we draw a dependency relationship between count and double.so double is depending on count.'),hi=c(),to=l("p"),di=o("lets continue."),pi=c(),ao=l("p"),ui=o("here we see data. data is not declared at the top level scope, as it is within the curly bracket block scope. so we are not going to record it down."),fi=c(),le=l("p"),vi=o("same thing goes with "),He=l("code"),mi=o("i"),wi=o("."),gi=c(),oo=l("p"),bi=o("here we encountered double again, so we mark it as referenced."),yi=c(),ro=l("p"),Ei=o("Math, a js global, we are going to ignore it."),_i=c(),se=l("p"),Si=o("here "),Re=l("code"),ki=o("values"),Ti=o(" is mutated."),Pi=c(),no=l("p"),Oi=o("now we reach the end of the script, the next step is to traverse the template AST."),Ci=c(),j=l("p"),xi=o("we start from the "),Je=l("code"),Ai=o("input"),Di=o(" element, which has a "),We=l("code"),ji=o("bind:value"),Mi=o("."),Ii=c(),M=l("p"),Ni=o("Here we are binding the value of the input to the variable "),Fe=l("code"),Hi=o("count"),Ri=o(". so we mark "),Le=l("code"),Ji=o("count"),Wi=o(" as referenced from template and mutated."),Fi=c(),b=l("p"),Li=o("Now we encountered the each block. Here we are iterating through the variable "),$e=l("code"),$i=o("values"),qi=o(" and we are using the variable "),qe=l("code"),Gi=o("value"),Ui=o(" as each item. So the template within the each block will have a new scope, where "),Ge=l("code"),Vi=o("value"),zi=o(" is declared. Also, we mark "),Ue=l("code"),Bi=o("values"),Yi=o(" as the dependency of the each block. This means that whenever "),Ve=l("code"),Ki=o("values"),Xi=o(" has changed, we are going to update the each block."),Zi=c(),lo=l("p"),Qi=o("...and, we mark values as referenced too."),ec=c(),I=l("p"),tc=o("next, we move into the each block and the div element. Here we mark "),ze=l("code"),ac=o("value"),oc=o(" as referenced from the template, we encounter "),Be=l("code"),rc=o("value"),nc=o(" again and we've reachead the end of the template."),lc=c(),so=l("p"),sc=o("and Svelte traverse through the script again, this time mainly for optimisation. figuring out which variables are not referenced, and does not need to be reactive."),ic=c(),io=l("p"),cc=o("Similarly, if a reactive declaration's dependency will never change, by seeing whether their dependencies were marked as mutated, we can mark it as static, which is more efficient, and much smaller in code size."),hc=c(),co=l("p"),dc=o("Next, Svelte traverse through the style."),pc=c(),ho=l("p"),uc=o("for each selector, it will determine whether it will match any elements in the template, and if it does, svelte will add a svelte-hash class name to the selector as well as the matched eelement. Although this will increase the specificity of the selector, but it will make the selector scoped only to the current svelte component."),fc=c(),po=l("p"),vc=o("At the end of this step, Svelte has figured out all the variables declared, their behavior and their relationship."),mc=c(),uo=l("p"),wc=o("With this, we are moving on to the rendering phase."),gc=c(),fo=l("p"),bc=o(`This step is where svelte will generate the javascript code.
There are 2 different compile targets, 1 is DOM, for the client side, and another is ssr, for the server side.`),yc=c(),vo=l("p"),Ec=o("Lets first take a look at the dom render target."),_c=c(),mo=l("p"),Sc=o("Here we have the source code. and here is the outline of how a dom output looks like."),kc=c(),v=l("p"),Tc=o("Here is what I called a fragment block. the create fragment function returns an object, that acts as a recipe to create the elements in the component. each method in the recipe object, represents a stage in the component lifecycle, here we have "),Ye=l("code"),Pc=o("c"),Oc=o(" for "),Ke=l("code"),Cc=o("create"),xc=o(", "),Xe=l("code"),Ac=o("m"),Dc=o(" for "),Ze=l("code"),jc=o("mounting"),Mc=o(", "),Qe=l("code"),Ic=o("p"),Nc=o(" for "),et=l("code"),Hc=o("update"),Rc=o(", and "),tt=l("code"),Jc=o("d"),Wc=o(" for "),at=l("code"),Fc=o("destroy"),Lc=o("."),$c=c(),wo=l("p"),qc=o("next on, we have the instance function. here's where the state and component logic goes into."),Gc=c(),x=l("p"),Uc=o("finally we have the svelte component class. so each svelte component is compiled into a class which is the default export. in the constructor, as you can see, calls the "),ot=l("code"),Vc=o("init"),zc=o(" function which takes in the "),rt=l("code"),Bc=o("instance"),Yc=o(" and "),nt=l("code"),Kc=o("create_fragment"),Xc=o(" function. and this is how the 3 different pieces of the svelte compoenent come together."),Zc=c(),go=l("p"),Qc=o("Now, svelte walks through the template again, and starts inserting code into output."),eh=c(),bo=l("p"),th=o("First we have the input element. we insert instructions to create the input element, mounting the element to the target, and remove the element from the target."),ah=c(),A=l("p"),oh=o("next we have the binding of the input value to the "),lt=l("code"),rh=o("count"),nh=o(" variable. we need an input handler to listen to the input changes, so we can update the value of the "),st=l("code"),lh=o("count"),sh=o(" variable. here we pull out the variables list, and add "),it=l("code"),ih=o("input_handler"),ch=o("."),hh=c(),yo=l("p"),dh=o("we set the input value based on the variable count and add event listener for input changes which we should remove event listener when we destroy the component."),ph=c(),N=l("p"),uh=o("and in the update phase, if the "),ct=l("code"),fh=o("count"),vh=o(" has changed, we need to update the value of the input based on the value of "),ht=l("code"),mh=o("count"),wh=o("."),gh=c(),Eo=l("p"),bh=o("next we move on to the each block."),yh=c(),H=l("p"),Eh=o("we create a new fragment block for the each block, which contains the recipe for creating elements for 1 each item. And because in the each block we have a child scope that defines the variable "),dt=l("code"),_h=o("value"),Sh=o(", we have a "),pt=l("code"),kh=o("get_each_context"),Th=o(" function to emulate that."),Ph=c(),_o=l("p"),Oh=o('Here we fast forward through the steps, where for each element, we insert code for how we create, mount, update and destroy them. If you are interested to know the details, you can check out my series of blog, called "Compile Svelte in your head".'),Ch=c(),ie=l("p"),xh=o("Now we look at how Svelte fills up the instance function. In most cases, Svelte just copies over whatever is written within the "),ut=l("code"),Ah=o("<script>"),Dh=o(" tag."),jh=c(),ce=l("p"),Mh=o("For reactive declarations, they were added inside the "),ft=l("code"),Ih=o("$$.update"),Nh=o(" function, and for each statement, we add an if statement to check whether their dependency has changed, based on the dependency relationship we've drawn earlier."),Hh=c(),So=l("p"),Rh=o("Now we need to declare and add those injected variables."),Jh=c(),he=l("p"),Wh=o("Finally, we return the list of variables that are "),ko=l("strong"),Fh=o("referenced by the template"),Lh=o(" only."),$h=c(),de=l("p"),qh=o("Now, to make the variables actually reactive, we instruments the "),vt=l("code"),Gh=o("$$invalidate"),Uh=o(" after each assignment statements, so that it will kickstart a next round of update cycle."),Vh=c(),To=l("p"),zh=o("So here you have it, the compile output for the DOM target."),Bh=c(),Po=l("p"),Yh=o("Let's take a quick look at how things going for compiling to the SSR target."),Kh=c(),Oo=l("p"),Xh=o("The structure of the output code for the SSR target is much simpler. it is a function that returns a string."),Zh=c(),pe=l("p"),Qh=o("Because there wont be any reactivity needed in the server, we can copy over the code verbatim from the script tag. same thing goes with reactive declarations, of course we need to remember to declare the injected variable, "),mt=l("code"),ed=o("double"),td=o("."),ad=c(),ue=l("p"),od=o("as we traverse through the template, we add insert strings or expressions into the output template literal. For the each block, we iterate through the variable "),wt=l("code"),rd=o("values"),nd=o(" and return the child elements as string."),ld=c(),Co=l("p"),sd=o("And there you go, the output code of a svelte component for SSR."),id=c(),xo=l("p"),cd=o("Finally, Svelte outputs the code in JS and CSS, with the code as string as well as the sourcemap."),hd=c(),Ao=l("p"),dd=o("These can be written into file system directly, or be consumed by your module bundler, such as rollup-svelte-plugin in rollup or svelte-loader for webpack."),pd=c(),Do=l("p"),ud=o(`So lets review again the svelte compilation pipeline,
Svelte parses the code into ast, runs a series of steps to analsye the code, tracking the variable references and dependencies. Then svelte generates the code depending on the compile target, whether it's for the client side or server-side.
And the output of the render step is in terms of JS and CSS, which can be written into a file / consumed by your build tools.`),fd=c(),jo=l("p"),vd=o("Thank you so much for listening. If you like to learn more about svelte, or if you have any questions about svelte, you can follow me on twitter. I am Li Hau. hope you have fun with the talks throughout the conference."),md=c(),Mo=l("p"),wd=o("See ya."),this.h()},l(p){u=s(p,"SECTION",{});var k=i(u);E=s(k,"H2",{});var kd=i(E);y=s(kd,"A",{href:!0,id:!0});var Td=i(y);U=r(Td,"Recorded talk"),Td.forEach(n),kd.forEach(n),k.forEach(n),f=h(p),w=s(p,"SECTION",{});var Ro=i(w);J=s(Ro,"H3",{});var Pd=i(J);V=s(Pd,"A",{href:!0,id:!0});var Od=i(V);rr=r(Od,"CityJS Conference 2020"),Od.forEach(n),Pd.forEach(n),nr=h(Ro),_=s(Ro,"IFRAME",{width:!0,height:!0,title:!0,src:!0,frameborder:!0,allow:!0}),i(_).forEach(n),Ro.forEach(n),Io=h(p),W=s(p,"SECTION",{});var Jo=i(W);kt=s(Jo,"H3",{});var Cd=i(kt);z=s(Cd,"A",{href:!0,id:!0});var xd=i(z);lr=r(xd,"MMT Tech Meetup - Sept 2020"),xd.forEach(n),Cd.forEach(n),sr=h(Jo),S=s(Jo,"IFRAME",{width:!0,height:!0,title:!0,src:!0,frameborder:!0,allow:!0}),i(S).forEach(n),Jo.forEach(n),No=h(p),F=s(p,"SECTION",{});var Wo=i(F);Tt=s(Wo,"H2",{});var Ad=i(Tt);B=s(Ad,"A",{href:!0,id:!0});var Dd=i(B);ir=r(Dd,"Slides"),Dd.forEach(n),Ad.forEach(n),cr=h(Wo),Y=s(Wo,"P",{});var Fo=i(Y);hr=r(Fo,"["),ve=s(Fo,"A",{href:!0});var jd=i(ve);dr=r(jd,"Link to slides"),jd.forEach(n),pr=r(Fo,"] (Left arrow and right arrow to navigate)"),Fo.forEach(n),Wo.forEach(n),Ho=h(p),t=s(p,"SECTION",{});var a=i(t);Pt=s(a,"H2",{});var Md=i(Pt);K=s(Md,"A",{href:!0,id:!0});var Id=i(K);ur=r(Id,"Script"),Id.forEach(n),Md.forEach(n),fr=h(a),X=s(a,"P",{});var Lo=i(X);vr=r(Lo,"Modern web frameworks allow us to describe our "),Ot=s(Lo,"STRONG",{});var Nd=i(Ot);mr=r(Nd,"UI"),Nd.forEach(n),wr=r(Lo," declaratively, as a function of state, of the application."),Lo.forEach(n),gr=h(a),Ct=s(a,"P",{});var Hd=i(Ct);br=r(Hd,"The function can be written in a form of template, or template-like syntax, which describes exactly how the view should look like, in all possible states."),Hd.forEach(n),yr=h(a),xt=s(a,"P",{});var Rd=i(xt);Er=r(Rd,"When the state change, the view should change as well."),Rd.forEach(n),_r=h(a),At=s(a,"P",{});var Jd=i(At);Sr=r(Jd,"We don't need to describe how one view transition to another view. We don't need to describe what elements to be added, removed or modified."),Jd.forEach(n),kr=h(a),Dt=s(a,"P",{});var Wd=i(Dt);jt=s(Wd,"STRONG",{});var Fd=i(jt);Tr=r(Fd,"Modern Web Framework do that for us."),Fd.forEach(n),Wd.forEach(n),Pr=h(a),Z=s(a,"P",{});var $o=i(Z);Or=r($o,"The "),me=s($o,"CODE",{class:!0});var Ld=i(me);Cr=r(Ld,"framework_magic"),Ld.forEach(n),xr=r($o," takes in 2 subsequent views and figure out how to transition from 1 to another."),$o.forEach(n),Ar=h(a),Mt=s(a,"P",{});var $d=i(Mt);Dr=r($d,"Modern web frameworks like React and Vue do that using a technique called a virtual DOM."),$d.forEach(n),jr=h(a),Q=s(a,"P",{});var qo=i(Q);Mr=r(qo,"To handle all the possible scenarios, this "),we=s(qo,"CODE",{class:!0});var qd=i(we);Ir=r(qd,"framework_magic"),qd.forEach(n),Nr=r(qo," could be very huge in code size, and it is independent of the application it is supporting."),qo.forEach(n),Hr=h(a),It=s(a,"P",{});var Gd=i(It);Rr=r(Gd,"For react is 40kb gzipped and vue2 is 23kb gzipped, vue3 is 10kb."),Gd.forEach(n),Jr=h(a),Nt=s(a,"P",{});var Ud=i(Nt);Wr=r(Ud,"and if your application is simple, it could disproportionately small in terms of code size relative to the framework library, which is shown in the gray portion of the chart."),Ud.forEach(n),Fr=h(a),ee=s(a,"P",{});var Go=i(ee);Lr=r(Go,"However, this doesnt have to be, "),Ht=s(Go,"STRONG",{});var Vd=i(Ht);$r=r(Vd,"the only way"),Vd.forEach(n),qr=r(Go," of doing things."),Go.forEach(n),Gr=h(a),te=s(a,"P",{});var Uo=i(te);Ur=r(Uo,"What if we could shift all of the work done in the "),ge=s(Uo,"CODE",{class:!0});var zd=i(ge);Vr=r(zd,"framework_magic"),zd.forEach(n),zr=r(Uo," from runtime to build time?"),Uo.forEach(n),Br=h(a),Rt=s(a,"P",{});var Bd=i(Rt);Yr=r(Bd,"We can analyse the code and figure out all the possible states and views, and the possible transitions between them, and generate just enough code to do just that?"),Bd.forEach(n),Kr=h(a),Jt=s(a,"P",{});var Yd=i(Jt);Xr=r(Yd,"And that's the core idea of Svelte."),Yd.forEach(n),Zr=h(a),D=s(a,"P",{});var gt=i(D);Qr=r(gt,"The Svelte compiler compiles the Svelte code into "),Wt=s(gt,"STRONG",{});var Kd=i(Wt);en=r(Kd,"optimised"),Kd.forEach(n),tn=r(gt," JavaScript code that "),Ft=s(gt,"STRONG",{});var Xd=i(Ft);an=r(Xd,"grows linearly"),Xd.forEach(n),on=r(gt," along with your application code."),gt.forEach(n),rn=h(a),Lt=s(a,"P",{});var Zd=i(Lt);nn=r(Zd,"and today we are going to look into the Svelte compiler."),Zd.forEach(n),ln=h(a),$t=s(a,"P",{});var Qd=i($t);sn=r(Qd,"Don't worry if you are not familiar with Svelte / compiler, I'll try my best to avoid the jargons and explain the general idea of the process."),Qd.forEach(n),cn=h(a),qt=s(a,"P",{});var ep=i(qt);hn=r(ep,"My name is Tan Li Hau, I am a software engineer at Shopee. Shopee is a e-commerce platform in South east asia that is based in Singapore."),ep.forEach(n),dn=h(a),Gt=s(a,"P",{});var tp=i(Gt);pn=r(tp,"I grew up in a lovely town called penang in malaysia, which has the best street food in malaysia, such as char koay teow, stir-fry flat rice noodles; rojak, a eclectic fruit salad with palm sugar, peanuts and chilli dressing, and dont get me started with food. Hopefully you guys can come visit Malaysia after this coronavirus pandemic is over."),tp.forEach(n),un=h(a),Ut=s(a,"P",{});var ap=i(Ut);fn=r(ap,"last but not the least, Im one of the maintainers of svelte"),ap.forEach(n),vn=h(a),Vt=s(a,"P",{});var op=i(Vt);mn=r(op,"Before we start talking about compilers, for the benefit of those who havn't have a chance to look into Svelte, lets take a look at how a svelte component looks like."),op.forEach(n),wn=h(a),ae=s(a,"P",{});var Vo=i(ae);gn=r(Vo,"a svelte component is written in a file with a "),be=s(Vo,"CODE",{class:!0});var rp=i(be);bn=r(rp,".svelte"),rp.forEach(n),yn=r(Vo," extension. Each file describes 1 svelte  component."),Vo.forEach(n),En=h(a),zt=s(a,"P",{});var np=i(zt);_n=r(np,"You can add 1 script tag to the component. The script tag allows you to define variable, just like how you would in any javascript code,  and you can reference the variables in your html template, with a curly bracket."),np.forEach(n),Sn=h(a),oe=s(a,"P",{});var zo=i(oe);kn=r(zo,"To add event listener, you use a "),ye=s(zo,"CODE",{class:!0});var lp=i(ye);Tn=r(lp,"on:"),lp.forEach(n),Pn=r(zo," directive, and you can update the variable just like this, and it will automatically updated in your DOM."),zo.forEach(n),On=h(a),Bt=s(a,"P",{});var sp=i(Bt);Cn=r(sp,"You can add a style tag and write some css to style your component. What's cool about it is that, the css is scoped within the component. so when i say button, background: red, only the button written in this component file has the background red. not the child component, not the parent component. just this component."),sp.forEach(n),xn=h(a),Ee=s(a,"P",{});var gd=i(Ee);Yt=s(gd,"STRONG",{});var ip=i(Yt);An=r(ip,"now"),ip.forEach(n),Dn=r(gd,", here is one of the most powerful, and somewhat controversial feature of svelte, reactive declarations."),gd.forEach(n),jn=h(a),g=s(a,"P",{});var T=i(g);Mn=r(T,"here you have a "),_e=s(T,"CODE",{class:!0});var cp=i(_e);In=r(cp,"double = count * 2"),cp.forEach(n),Nn=r(T,", with a dollar + colon sign in front of the statement. this means that the variable "),Se=s(T,"CODE",{class:!0});var hp=i(Se);Hn=r(hp,"double"),hp.forEach(n),Rn=r(T," is always 2 times of "),ke=s(T,"CODE",{class:!0});var dp=i(ke);Jn=r(dp,"count"),dp.forEach(n),Wn=r(T,", whenever the value of "),Te=s(T,"CODE",{class:!0});var pp=i(Te);Fn=r(pp,"count"),pp.forEach(n),Ln=r(T," has changed, the value of "),Pe=s(T,"CODE",{class:!0});var up=i(Pe);$n=r(up,"double"),up.forEach(n),qn=r(T," will update as well."),T.forEach(n),Gn=h(a),Kt=s(a,"P",{});var fp=i(Kt);Un=r(fp,"This definitely feels weird in the beginning, but the more you use it, you'll ask yourself why didn't we have this earlier."),fp.forEach(n),Vn=h(a),Xt=s(a,"P",{});var vp=i(Xt);zn=r(vp,"So, here we have 1 big red button, and a text of multiply equation as a Svelte component."),vp.forEach(n),Bn=h(a),Oe=s(a,"P",{});var bd=i(Oe);Yn=r(bd,"I am gonna pause here for a moment, and ask you this question, "),Zt=s(bd,"STRONG",{});var mp=i(Zt);Kn=r(mp,"how would you implement this, if you are not allowed to use any framework and you have to write it in Vanilla JavaScript?"),mp.forEach(n),bd.forEach(n),Xn=h(a),Qt=s(a,"P",{});var wp=i(Qt);ea=s(wp,"EM",{});var gp=i(ea);Zn=r(gp,"(pause)"),gp.forEach(n),wp.forEach(n),Qn=h(a),ta=s(a,"P",{});var bp=i(ta);el=r(bp,"So, firstly we are going to start with the variable declaration."),bp.forEach(n),tl=h(a),aa=s(a,"P",{});var yp=i(aa);al=r(yp,"Next we create the text with document.createTextNode, and insert it to the parent"),yp.forEach(n),ol=h(a),oa=s(a,"P",{});var Ep=i(oa);rl=r(Ep,"Next we create the button, change the text, add event listener and insert it to the parent."),Ep.forEach(n),nl=h(a),ra=s(a,"P",{});var _p=i(ra);ll=r(_p,"To update the text when the count is updated, we create an update function, where we update the value of double and update the content of the text."),_p.forEach(n),sl=h(a),na=s(a,"P",{});var Sp=i(na);il=r(Sp,"Finally for the style tag, we create a style tag, set the content and insert into the head."),Sp.forEach(n),cl=h(a),la=s(a,"P",{});var kp=i(la);hl=r(kp,"To make sure that the button only targets this button that we just created, we add a class to the button."),kp.forEach(n),dl=h(a),sa=s(a,"P",{});var Tp=i(sa);pl=r(Tp,"Here the class name is random, but it could be generated based on the hash of the style code, so you get consistent class name."),Tp.forEach(n),ul=h(a),ia=s(a,"P",{});var Pp=i(ia);ca=s(Pp,"EM",{});var Op=i(ca);fl=r(Op,"(CLICK TO VIEW JS OUTPUT)"),Op.forEach(n),Pp.forEach(n),vl=h(a),ha=s(a,"P",{});var Cp=i(ha);ml=r(Cp,"In fact if you take a look at the svelte generated JS output, it is very similar to the code we just wrote."),Cp.forEach(n),wl=h(a),re=s(a,"P",{});var Bo=i(re);gl=r(Bo,"So, this is just the code you need to "),da=s(Bo,"STRONG",{});var xp=i(da);bl=r(xp,"create a button and a text"),xp.forEach(n),yl=r(Bo,". You don't need 40KB Virtual DOM library to recreate the same component."),Bo.forEach(n),El=h(a),pa=s(a,"P",{});var Ap=i(pa);_l=r(Ap,"Of course, you don't have to write all of these yourself."),Ap.forEach(n),Sl=h(a),ua=s(a,"P",{});var Dp=i(ua);kl=r(Dp,"The Svelte compiler will do it for you. It will analyse the code above, and generate the code below for you."),Dp.forEach(n),Tl=h(a),fa=s(a,"P",{});var jp=i(fa);Pl=r(jp,'And now, if you try to choose "SSR" as the generated output, you can see now Svelte generates a function that returns a string composed using template literals.'),jp.forEach(n),Ol=h(a),va=s(a,"P",{});var Mp=i(va);Cl=r(Mp,"This is a few orders more performant than generating a tree object and serialising them into a HTML string."),Mp.forEach(n),xl=h(a),ma=s(a,"P",{});var Ip=i(ma);wa=s(Ip,"EM",{});var Np=i(wa);Al=r(Np,"(DONT MOVE)"),Np.forEach(n),Ip.forEach(n),Dl=h(a),Ce=s(a,"P",{});var yd=i(Ce);jl=r(yd,"So, Let's take a few more examples of the Svelte syntax, and along the way, I hope you ask yourself this question, "),ga=s(yd,"STRONG",{});var Hp=i(ga);Ml=r(Hp,'"how do i convert this / write this in plain JavaScript?"'),Hp.forEach(n),yd.forEach(n),Il=h(a),ba=s(a,"P",{});var Rp=i(ba);Nl=r(Rp,"and don't worry, you can find this repl on the svelte website. and you can compare the input and the js output anyway you want."),Rp.forEach(n),Hl=h(a),ya=s(a,"P",{});var Jp=i(ya);Ea=s(Jp,"EM",{});var Wp=i(Ea);Rl=r(Wp,"(OKAY NOW MOVE)"),Wp.forEach(n),Jp.forEach(n),Jl=h(a),O=s(a,"P",{});var L=i(O);Wl=r(L,"To express logics within the template, Svelte provides logic block, such as "),_a=s(L,"STRONG",{});var Fp=i(_a);xe=s(Fp,"CODE",{class:!0});var Lp=i(xe);Fl=r(Lp,"{#if}"),Lp.forEach(n),Fp.forEach(n),Ll=r(L,", "),Sa=s(L,"STRONG",{});var $p=i(Sa);Ae=s($p,"CODE",{class:!0});var qp=i(Ae);$l=r(qp,"{#await}"),qp.forEach(n),$p.forEach(n),ql=r(L,", and "),ka=s(L,"STRONG",{});var Gp=i(ka);De=s(Gp,"CODE",{class:!0});var Up=i(De);Gl=r(Up,"{#each}"),Up.forEach(n),Gp.forEach(n),Ul=r(L,"."),L.forEach(n),Vl=h(a),ne=s(a,"P",{});var Yo=i(ne);zl=r(Yo,"To reduce the boilerplate code for binding a variable to an input, Svelte provides the "),je=s(Yo,"CODE",{class:!0});var Vp=i(je);Bl=r(Vp,"bind:"),Vp.forEach(n),Yl=r(Yo," directive."),Yo.forEach(n),Kl=h(a),C=s(a,"P",{});var $=i(C);Xl=r($,"To provide transition for elements coming into or out of the DOM, Svelte provides the "),Me=s($,"CODE",{class:!0});var zp=i(Me);Zl=r(zp,"transition"),zp.forEach(n),Ql=r($,", "),Ie=s($,"CODE",{class:!0});var Bp=i(Ie);es=r(Bp,"in"),Bp.forEach(n),ts=r($," and "),Ne=s($,"CODE",{class:!0});var Yp=i(Ne);as=r(Yp,"out"),Yp.forEach(n),os=r($," directive."),$.forEach(n),rs=h(a),Ta=s(a,"P",{});var Kp=i(Ta);ns=r(Kp,"To compose Components, Svelte provides slots and templates similar to the Web Component APIs."),Kp.forEach(n),ls=h(a),Pa=s(a,"P",{});var Xp=i(Pa);ss=r(Xp,"There's so much I would like to share here, but I have to segue into the Svelte compiler, because that's the main topic of today's talk."),Xp.forEach(n),is=h(a),Oa=s(a,"P",{});var Zp=i(Oa);cs=r(Zp,"Now, finally, let's take a look at the Svelte compiler."),Zp.forEach(n),hs=h(a),Ca=s(a,"P",{});var Qp=i(Ca);ds=r(Qp,"So, how does a compiler works?"),Qp.forEach(n),ps=h(a),xa=s(a,"P",{});var eu=i(xa);us=r(eu,"A compiler first reads through your code, and break it down into smaller pieces, called tokens."),eu.forEach(n),fs=h(a),Aa=s(a,"P",{});var tu=i(Aa);vs=r(tu,"The compiler then goes through this list of tokens and arrange them into a tree structure, according to the grammar of the language. The tree structure is what a compiler call \u201CAbstract syntax tree\u201D or AST for short."),tu.forEach(n),ms=h(a),Da=s(a,"P",{});var au=i(Da);ws=r(au,"An AST is a tree representation of the input code."),au.forEach(n),gs=h(a),ja=s(a,"P",{});var ou=i(ja);bs=r(ou,`And what the compiler sometimes do, is to analyse and apply transformation to the AST.
Using tree traversal algorithms, such as depth first search`),ou.forEach(n),ys=h(a),Ma=s(a,"P",{});var ru=i(Ma);Es=r(ru,"And finally, the compiler generates a code output based on the final AST."),ru.forEach(n),_s=h(a),Ia=s(a,"P",{});var nu=i(Ia);Ss=r(nu,"In summary, a generic compilation process involves parsing the code to an AST, doing analysis, optimsiation or transformation on the AST, and then generate code out from the AST."),nu.forEach(n),ks=h(a),Na=s(a,"P",{});var lu=i(Na);Ts=r(lu,"Finally, let's take a look how Svelte compiler works."),lu.forEach(n),Ps=h(a),Ha=s(a,"P",{});var su=i(Ha);Os=r(su,"Svelte parses the Svelte code into AST"),su.forEach(n),Cs=h(a),Ra=s(a,"P",{});var iu=i(Ra);xs=r(iu,"Svelte then analyses the AST, which we will explore in detailed later."),iu.forEach(n),As=h(a),Ja=s(a,"P",{});var cu=i(Ja);Ds=r(cu,`With the analysis, Svelte generates JavaScript code depending on the compile target, whether it's for SSR or it's for the browser.
Finally, js and css is generated, and can be written into a file or be consumed by your build process.`),cu.forEach(n),js=h(a),Wa=s(a,"P",{});var hu=i(Wa);Ms=r(hu,"So lets start from the beginning, the parsing."),hu.forEach(n),Is=h(a),Fa=s(a,"P",{});var du=i(Fa);Ns=r(du,"Here is a Svelte component that we are going to use throughout this talk."),du.forEach(n),Hs=h(a),La=s(a,"P",{});var pu=i(La);Rs=r(pu,"Svelte, implements its own parser"),pu.forEach(n),Js=h(a),$a=s(a,"P",{});var uu=i($a);Ws=r(uu,"That parses the html syntax, as well as logic blocks, like each, if, and await"),uu.forEach(n),Fs=h(a),qa=s(a,"P",{});var fu=i(qa);Ls=r(fu,`Because js is a fairly complex language, whenever svelte encounters a script tag, or a curly brackets, it will hand it over to acorn, a lightweight JavaScript parser, to parse the JS content.
The same thing goes with css as well. svelte uses css-tree to parse CSS content in between the style tag.`),fu.forEach(n),$s=h(a),Ga=s(a,"P",{});var vu=i(Ga);qs=r(vu,"So, through the process, the svelte code is broken down into tokens, and is arranged into the Svelte AST."),vu.forEach(n),Gs=h(a),Ua=s(a,"P",{});var mu=i(Ua);Us=r(mu,"If you interested to see how the Svelte AST looks like, you can check them out at ASTExplorer.net."),mu.forEach(n),Vs=h(a),Va=s(a,"P",{});var wu=i(Va);zs=r(wu,"The next step is to analyse the AST."),wu.forEach(n),Bs=h(a),za=s(a,"P",{});var gu=i(za);Ys=r(gu,"Here, our code is already in AST, BUT to help visualise the process, i'm going to show you the original code."),gu.forEach(n),Ks=h(a),Ba=s(a,"P",{});var bu=i(Ba);Xs=r(bu,"The first thing Svelte do is to traverse through the script AST."),bu.forEach(n),Zs=h(a),Ya=s(a,"P",{});var yu=i(Ya);Qs=r(yu,"Whenever it encounters a variable, in this case, count, it will record down the variable name."),yu.forEach(n),ei=h(a),Ka=s(a,"P",{});var Eu=i(Ka);ti=r(Eu,"here we record values and double."),Eu.forEach(n),ai=h(a),Xa=s(a,"P",{});var _u=i(Xa);oi=r(_u,'the "double" here, in this svelte code is a reactive declared variable. but to vanilla JavaScript, we are assigning value to this variable "double", which is not declared anywhere.'),_u.forEach(n),ri=h(a),Za=s(a,"P",{});var Su=i(Za);ni=r(Su,'in strict mode, this is a "assignment to undeclared variable" error.'),Su.forEach(n),li=h(a),Qa=s(a,"P",{});var ku=i(Qa);si=r(ku,'Svelte marks the variable, "double", as "injected", so the declaration of the variable will be injected later. other examples of injected variables are svelte magic global, such as $$props, or a $ prefix of a store variable.'),ku.forEach(n),ii=h(a),eo=s(a,"P",{});var Tu=i(eo);ci=r(Tu,'here we encounter "count" again, this time its being referenced, instead of being assinged to a value, and it is used to compute the value of double. so we draw a dependency relationship between count and double.so double is depending on count.'),Tu.forEach(n),hi=h(a),to=s(a,"P",{});var Pu=i(to);di=r(Pu,"lets continue."),Pu.forEach(n),pi=h(a),ao=s(a,"P",{});var Ou=i(ao);ui=r(Ou,"here we see data. data is not declared at the top level scope, as it is within the curly bracket block scope. so we are not going to record it down."),Ou.forEach(n),fi=h(a),le=s(a,"P",{});var Ko=i(le);vi=r(Ko,"same thing goes with "),He=s(Ko,"CODE",{class:!0});var Cu=i(He);mi=r(Cu,"i"),Cu.forEach(n),wi=r(Ko,"."),Ko.forEach(n),gi=h(a),oo=s(a,"P",{});var xu=i(oo);bi=r(xu,"here we encountered double again, so we mark it as referenced."),xu.forEach(n),yi=h(a),ro=s(a,"P",{});var Au=i(ro);Ei=r(Au,"Math, a js global, we are going to ignore it."),Au.forEach(n),_i=h(a),se=s(a,"P",{});var Xo=i(se);Si=r(Xo,"here "),Re=s(Xo,"CODE",{class:!0});var Du=i(Re);ki=r(Du,"values"),Du.forEach(n),Ti=r(Xo," is mutated."),Xo.forEach(n),Pi=h(a),no=s(a,"P",{});var ju=i(no);Oi=r(ju,"now we reach the end of the script, the next step is to traverse the template AST."),ju.forEach(n),Ci=h(a),j=s(a,"P",{});var bt=i(j);xi=r(bt,"we start from the "),Je=s(bt,"CODE",{class:!0});var Mu=i(Je);Ai=r(Mu,"input"),Mu.forEach(n),Di=r(bt," element, which has a "),We=s(bt,"CODE",{class:!0});var Iu=i(We);ji=r(Iu,"bind:value"),Iu.forEach(n),Mi=r(bt,"."),bt.forEach(n),Ii=h(a),M=s(a,"P",{});var yt=i(M);Ni=r(yt,"Here we are binding the value of the input to the variable "),Fe=s(yt,"CODE",{class:!0});var Nu=i(Fe);Hi=r(Nu,"count"),Nu.forEach(n),Ri=r(yt,". so we mark "),Le=s(yt,"CODE",{class:!0});var Hu=i(Le);Ji=r(Hu,"count"),Hu.forEach(n),Wi=r(yt," as referenced from template and mutated."),yt.forEach(n),Fi=h(a),b=s(a,"P",{});var P=i(b);Li=r(P,"Now we encountered the each block. Here we are iterating through the variable "),$e=s(P,"CODE",{class:!0});var Ru=i($e);$i=r(Ru,"values"),Ru.forEach(n),qi=r(P," and we are using the variable "),qe=s(P,"CODE",{class:!0});var Ju=i(qe);Gi=r(Ju,"value"),Ju.forEach(n),Ui=r(P," as each item. So the template within the each block will have a new scope, where "),Ge=s(P,"CODE",{class:!0});var Wu=i(Ge);Vi=r(Wu,"value"),Wu.forEach(n),zi=r(P," is declared. Also, we mark "),Ue=s(P,"CODE",{class:!0});var Fu=i(Ue);Bi=r(Fu,"values"),Fu.forEach(n),Yi=r(P," as the dependency of the each block. This means that whenever "),Ve=s(P,"CODE",{class:!0});var Lu=i(Ve);Ki=r(Lu,"values"),Lu.forEach(n),Xi=r(P," has changed, we are going to update the each block."),P.forEach(n),Zi=h(a),lo=s(a,"P",{});var $u=i(lo);Qi=r($u,"...and, we mark values as referenced too."),$u.forEach(n),ec=h(a),I=s(a,"P",{});var Et=i(I);tc=r(Et,"next, we move into the each block and the div element. Here we mark "),ze=s(Et,"CODE",{class:!0});var qu=i(ze);ac=r(qu,"value"),qu.forEach(n),oc=r(Et," as referenced from the template, we encounter "),Be=s(Et,"CODE",{class:!0});var Gu=i(Be);rc=r(Gu,"value"),Gu.forEach(n),nc=r(Et," again and we've reachead the end of the template."),Et.forEach(n),lc=h(a),so=s(a,"P",{});var Uu=i(so);sc=r(Uu,"and Svelte traverse through the script again, this time mainly for optimisation. figuring out which variables are not referenced, and does not need to be reactive."),Uu.forEach(n),ic=h(a),io=s(a,"P",{});var Vu=i(io);cc=r(Vu,"Similarly, if a reactive declaration's dependency will never change, by seeing whether their dependencies were marked as mutated, we can mark it as static, which is more efficient, and much smaller in code size."),Vu.forEach(n),hc=h(a),co=s(a,"P",{});var zu=i(co);dc=r(zu,"Next, Svelte traverse through the style."),zu.forEach(n),pc=h(a),ho=s(a,"P",{});var Bu=i(ho);uc=r(Bu,"for each selector, it will determine whether it will match any elements in the template, and if it does, svelte will add a svelte-hash class name to the selector as well as the matched eelement. Although this will increase the specificity of the selector, but it will make the selector scoped only to the current svelte component."),Bu.forEach(n),fc=h(a),po=s(a,"P",{});var Yu=i(po);vc=r(Yu,"At the end of this step, Svelte has figured out all the variables declared, their behavior and their relationship."),Yu.forEach(n),mc=h(a),uo=s(a,"P",{});var Ku=i(uo);wc=r(Ku,"With this, we are moving on to the rendering phase."),Ku.forEach(n),gc=h(a),fo=s(a,"P",{});var Xu=i(fo);bc=r(Xu,`This step is where svelte will generate the javascript code.
There are 2 different compile targets, 1 is DOM, for the client side, and another is ssr, for the server side.`),Xu.forEach(n),yc=h(a),vo=s(a,"P",{});var Zu=i(vo);Ec=r(Zu,"Lets first take a look at the dom render target."),Zu.forEach(n),_c=h(a),mo=s(a,"P",{});var Qu=i(mo);Sc=r(Qu,"Here we have the source code. and here is the outline of how a dom output looks like."),Qu.forEach(n),kc=h(a),v=s(a,"P",{});var m=i(v);Tc=r(m,"Here is what I called a fragment block. the create fragment function returns an object, that acts as a recipe to create the elements in the component. each method in the recipe object, represents a stage in the component lifecycle, here we have "),Ye=s(m,"CODE",{class:!0});var ef=i(Ye);Pc=r(ef,"c"),ef.forEach(n),Oc=r(m," for "),Ke=s(m,"CODE",{class:!0});var tf=i(Ke);Cc=r(tf,"create"),tf.forEach(n),xc=r(m,", "),Xe=s(m,"CODE",{class:!0});var af=i(Xe);Ac=r(af,"m"),af.forEach(n),Dc=r(m," for "),Ze=s(m,"CODE",{class:!0});var of=i(Ze);jc=r(of,"mounting"),of.forEach(n),Mc=r(m,", "),Qe=s(m,"CODE",{class:!0});var rf=i(Qe);Ic=r(rf,"p"),rf.forEach(n),Nc=r(m," for "),et=s(m,"CODE",{class:!0});var nf=i(et);Hc=r(nf,"update"),nf.forEach(n),Rc=r(m,", and "),tt=s(m,"CODE",{class:!0});var lf=i(tt);Jc=r(lf,"d"),lf.forEach(n),Wc=r(m," for "),at=s(m,"CODE",{class:!0});var sf=i(at);Fc=r(sf,"destroy"),sf.forEach(n),Lc=r(m,"."),m.forEach(n),$c=h(a),wo=s(a,"P",{});var cf=i(wo);qc=r(cf,"next on, we have the instance function. here's where the state and component logic goes into."),cf.forEach(n),Gc=h(a),x=s(a,"P",{});var q=i(x);Uc=r(q,"finally we have the svelte component class. so each svelte component is compiled into a class which is the default export. in the constructor, as you can see, calls the "),ot=s(q,"CODE",{class:!0});var hf=i(ot);Vc=r(hf,"init"),hf.forEach(n),zc=r(q," function which takes in the "),rt=s(q,"CODE",{class:!0});var df=i(rt);Bc=r(df,"instance"),df.forEach(n),Yc=r(q," and "),nt=s(q,"CODE",{class:!0});var pf=i(nt);Kc=r(pf,"create_fragment"),pf.forEach(n),Xc=r(q," function. and this is how the 3 different pieces of the svelte compoenent come together."),q.forEach(n),Zc=h(a),go=s(a,"P",{});var uf=i(go);Qc=r(uf,"Now, svelte walks through the template again, and starts inserting code into output."),uf.forEach(n),eh=h(a),bo=s(a,"P",{});var ff=i(bo);th=r(ff,"First we have the input element. we insert instructions to create the input element, mounting the element to the target, and remove the element from the target."),ff.forEach(n),ah=h(a),A=s(a,"P",{});var G=i(A);oh=r(G,"next we have the binding of the input value to the "),lt=s(G,"CODE",{class:!0});var vf=i(lt);rh=r(vf,"count"),vf.forEach(n),nh=r(G," variable. we need an input handler to listen to the input changes, so we can update the value of the "),st=s(G,"CODE",{class:!0});var mf=i(st);lh=r(mf,"count"),mf.forEach(n),sh=r(G," variable. here we pull out the variables list, and add "),it=s(G,"CODE",{class:!0});var wf=i(it);ih=r(wf,"input_handler"),wf.forEach(n),ch=r(G,"."),G.forEach(n),hh=h(a),yo=s(a,"P",{});var gf=i(yo);dh=r(gf,"we set the input value based on the variable count and add event listener for input changes which we should remove event listener when we destroy the component."),gf.forEach(n),ph=h(a),N=s(a,"P",{});var _t=i(N);uh=r(_t,"and in the update phase, if the "),ct=s(_t,"CODE",{class:!0});var bf=i(ct);fh=r(bf,"count"),bf.forEach(n),vh=r(_t," has changed, we need to update the value of the input based on the value of "),ht=s(_t,"CODE",{class:!0});var yf=i(ht);mh=r(yf,"count"),yf.forEach(n),wh=r(_t,"."),_t.forEach(n),gh=h(a),Eo=s(a,"P",{});var Ef=i(Eo);bh=r(Ef,"next we move on to the each block."),Ef.forEach(n),yh=h(a),H=s(a,"P",{});var St=i(H);Eh=r(St,"we create a new fragment block for the each block, which contains the recipe for creating elements for 1 each item. And because in the each block we have a child scope that defines the variable "),dt=s(St,"CODE",{class:!0});var _f=i(dt);_h=r(_f,"value"),_f.forEach(n),Sh=r(St,", we have a "),pt=s(St,"CODE",{class:!0});var Sf=i(pt);kh=r(Sf,"get_each_context"),Sf.forEach(n),Th=r(St," function to emulate that."),St.forEach(n),Ph=h(a),_o=s(a,"P",{});var kf=i(_o);Oh=r(kf,'Here we fast forward through the steps, where for each element, we insert code for how we create, mount, update and destroy them. If you are interested to know the details, you can check out my series of blog, called "Compile Svelte in your head".'),kf.forEach(n),Ch=h(a),ie=s(a,"P",{});var Zo=i(ie);xh=r(Zo,"Now we look at how Svelte fills up the instance function. In most cases, Svelte just copies over whatever is written within the "),ut=s(Zo,"CODE",{class:!0});var Tf=i(ut);Ah=r(Tf,"<script>"),Tf.forEach(n),Dh=r(Zo," tag."),Zo.forEach(n),jh=h(a),ce=s(a,"P",{});var Qo=i(ce);Mh=r(Qo,"For reactive declarations, they were added inside the "),ft=s(Qo,"CODE",{class:!0});var Pf=i(ft);Ih=r(Pf,"$$.update"),Pf.forEach(n),Nh=r(Qo," function, and for each statement, we add an if statement to check whether their dependency has changed, based on the dependency relationship we've drawn earlier."),Qo.forEach(n),Hh=h(a),So=s(a,"P",{});var Of=i(So);Rh=r(Of,"Now we need to declare and add those injected variables."),Of.forEach(n),Jh=h(a),he=s(a,"P",{});var er=i(he);Wh=r(er,"Finally, we return the list of variables that are "),ko=s(er,"STRONG",{});var Cf=i(ko);Fh=r(Cf,"referenced by the template"),Cf.forEach(n),Lh=r(er," only."),er.forEach(n),$h=h(a),de=s(a,"P",{});var tr=i(de);qh=r(tr,"Now, to make the variables actually reactive, we instruments the "),vt=s(tr,"CODE",{class:!0});var xf=i(vt);Gh=r(xf,"$$invalidate"),xf.forEach(n),Uh=r(tr," after each assignment statements, so that it will kickstart a next round of update cycle."),tr.forEach(n),Vh=h(a),To=s(a,"P",{});var Af=i(To);zh=r(Af,"So here you have it, the compile output for the DOM target."),Af.forEach(n),Bh=h(a),Po=s(a,"P",{});var Df=i(Po);Yh=r(Df,"Let's take a quick look at how things going for compiling to the SSR target."),Df.forEach(n),Kh=h(a),Oo=s(a,"P",{});var jf=i(Oo);Xh=r(jf,"The structure of the output code for the SSR target is much simpler. it is a function that returns a string."),jf.forEach(n),Zh=h(a),pe=s(a,"P",{});var ar=i(pe);Qh=r(ar,"Because there wont be any reactivity needed in the server, we can copy over the code verbatim from the script tag. same thing goes with reactive declarations, of course we need to remember to declare the injected variable, "),mt=s(ar,"CODE",{class:!0});var Mf=i(mt);ed=r(Mf,"double"),Mf.forEach(n),td=r(ar,"."),ar.forEach(n),ad=h(a),ue=s(a,"P",{});var or=i(ue);od=r(or,"as we traverse through the template, we add insert strings or expressions into the output template literal. For the each block, we iterate through the variable "),wt=s(or,"CODE",{class:!0});var If=i(wt);rd=r(If,"values"),If.forEach(n),nd=r(or," and return the child elements as string."),or.forEach(n),ld=h(a),Co=s(a,"P",{});var Nf=i(Co);sd=r(Nf,"And there you go, the output code of a svelte component for SSR."),Nf.forEach(n),id=h(a),xo=s(a,"P",{});var Hf=i(xo);cd=r(Hf,"Finally, Svelte outputs the code in JS and CSS, with the code as string as well as the sourcemap."),Hf.forEach(n),hd=h(a),Ao=s(a,"P",{});var Rf=i(Ao);dd=r(Rf,"These can be written into file system directly, or be consumed by your module bundler, such as rollup-svelte-plugin in rollup or svelte-loader for webpack."),Rf.forEach(n),pd=h(a),Do=s(a,"P",{});var Jf=i(Do);ud=r(Jf,`So lets review again the svelte compilation pipeline,
Svelte parses the code into ast, runs a series of steps to analsye the code, tracking the variable references and dependencies. Then svelte generates the code depending on the compile target, whether it's for the client side or server-side.
And the output of the render step is in terms of JS and CSS, which can be written into a file / consumed by your build tools.`),Jf.forEach(n),fd=h(a),jo=s(a,"P",{});var Wf=i(jo);vd=r(Wf,"Thank you so much for listening. If you like to learn more about svelte, or if you have any questions about svelte, you can follow me on twitter. I am Li Hau. hope you have fun with the talks throughout the conference."),Wf.forEach(n),md=h(a),Mo=s(a,"P",{});var Ff=i(Mo);wd=r(Ff,"See ya."),Ff.forEach(n),a.forEach(n),this.h()},h(){d(y,"href","#recorded-talk"),d(y,"id","recorded-talk"),d(V,"href","#cityjs-conference-2020"),d(V,"id","cityjs-conference-2020"),d(_,"width","560"),d(_,"height","315"),d(_,"title","CityJS Conference 2020"),qf(_.src,_d="https://www.youtube.com/embed/sP7dtZm_Wx0?start=6618")||d(_,"src",_d),d(_,"frameborder","0"),d(_,"allow","accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"),_.allowFullscreen=!0,d(z,"href","#mmt-tech-meetup-sept-2020"),d(z,"id","mmt-tech-meetup-sept-2020"),d(S,"width","560"),d(S,"height","315"),d(S,"title","MMT Tech Meetup - Sept 2020"),qf(S.src,Sd="https://www.youtube.com/embed/tT1altUaaJU")||d(S,"src",Sd),d(S,"frameborder","0"),d(S,"allow","accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"),S.allowFullscreen=!0,d(B,"href","#slides"),d(B,"id","slides"),d(ve,"href","/slides/svelte-compiler/"),d(K,"href","#script"),d(K,"id","script"),d(me,"class","inline"),d(we,"class","inline"),d(ge,"class","inline"),d(be,"class","inline"),d(ye,"class","inline"),d(_e,"class","inline"),d(Se,"class","inline"),d(ke,"class","inline"),d(Te,"class","inline"),d(Pe,"class","inline"),d(xe,"class","inline"),d(Ae,"class","inline"),d(De,"class","inline"),d(je,"class","inline"),d(Me,"class","inline"),d(Ie,"class","inline"),d(Ne,"class","inline"),d(He,"class","inline"),d(Re,"class","inline"),d(Je,"class","inline"),d(We,"class","inline"),d(Fe,"class","inline"),d(Le,"class","inline"),d($e,"class","inline"),d(qe,"class","inline"),d(Ge,"class","inline"),d(Ue,"class","inline"),d(Ve,"class","inline"),d(ze,"class","inline"),d(Be,"class","inline"),d(Ye,"class","inline"),d(Ke,"class","inline"),d(Xe,"class","inline"),d(Ze,"class","inline"),d(Qe,"class","inline"),d(et,"class","inline"),d(tt,"class","inline"),d(at,"class","inline"),d(ot,"class","inline"),d(rt,"class","inline"),d(nt,"class","inline"),d(lt,"class","inline"),d(st,"class","inline"),d(it,"class","inline"),d(ct,"class","inline"),d(ht,"class","inline"),d(dt,"class","inline"),d(pt,"class","inline"),d(ut,"class","inline"),d(ft,"class","inline"),d(vt,"class","inline"),d(mt,"class","inline"),d(wt,"class","inline")},m(p,k){R(p,u,k),e(u,E),e(E,y),e(y,U),R(p,f,k),R(p,w,k),e(w,J),e(J,V),e(V,rr),e(w,nr),e(w,_),R(p,Io,k),R(p,W,k),e(W,kt),e(kt,z),e(z,lr),e(W,sr),e(W,S),R(p,No,k),R(p,F,k),e(F,Tt),e(Tt,B),e(B,ir),e(F,cr),e(F,Y),e(Y,hr),e(Y,ve),e(ve,dr),e(Y,pr),R(p,Ho,k),R(p,t,k),e(t,Pt),e(Pt,K),e(K,ur),e(t,fr),e(t,X),e(X,vr),e(X,Ot),e(Ot,mr),e(X,wr),e(t,gr),e(t,Ct),e(Ct,br),e(t,yr),e(t,xt),e(xt,Er),e(t,_r),e(t,At),e(At,Sr),e(t,kr),e(t,Dt),e(Dt,jt),e(jt,Tr),e(t,Pr),e(t,Z),e(Z,Or),e(Z,me),e(me,Cr),e(Z,xr),e(t,Ar),e(t,Mt),e(Mt,Dr),e(t,jr),e(t,Q),e(Q,Mr),e(Q,we),e(we,Ir),e(Q,Nr),e(t,Hr),e(t,It),e(It,Rr),e(t,Jr),e(t,Nt),e(Nt,Wr),e(t,Fr),e(t,ee),e(ee,Lr),e(ee,Ht),e(Ht,$r),e(ee,qr),e(t,Gr),e(t,te),e(te,Ur),e(te,ge),e(ge,Vr),e(te,zr),e(t,Br),e(t,Rt),e(Rt,Yr),e(t,Kr),e(t,Jt),e(Jt,Xr),e(t,Zr),e(t,D),e(D,Qr),e(D,Wt),e(Wt,en),e(D,tn),e(D,Ft),e(Ft,an),e(D,on),e(t,rn),e(t,Lt),e(Lt,nn),e(t,ln),e(t,$t),e($t,sn),e(t,cn),e(t,qt),e(qt,hn),e(t,dn),e(t,Gt),e(Gt,pn),e(t,un),e(t,Ut),e(Ut,fn),e(t,vn),e(t,Vt),e(Vt,mn),e(t,wn),e(t,ae),e(ae,gn),e(ae,be),e(be,bn),e(ae,yn),e(t,En),e(t,zt),e(zt,_n),e(t,Sn),e(t,oe),e(oe,kn),e(oe,ye),e(ye,Tn),e(oe,Pn),e(t,On),e(t,Bt),e(Bt,Cn),e(t,xn),e(t,Ee),e(Ee,Yt),e(Yt,An),e(Ee,Dn),e(t,jn),e(t,g),e(g,Mn),e(g,_e),e(_e,In),e(g,Nn),e(g,Se),e(Se,Hn),e(g,Rn),e(g,ke),e(ke,Jn),e(g,Wn),e(g,Te),e(Te,Fn),e(g,Ln),e(g,Pe),e(Pe,$n),e(g,qn),e(t,Gn),e(t,Kt),e(Kt,Un),e(t,Vn),e(t,Xt),e(Xt,zn),e(t,Bn),e(t,Oe),e(Oe,Yn),e(Oe,Zt),e(Zt,Kn),e(t,Xn),e(t,Qt),e(Qt,ea),e(ea,Zn),e(t,Qn),e(t,ta),e(ta,el),e(t,tl),e(t,aa),e(aa,al),e(t,ol),e(t,oa),e(oa,rl),e(t,nl),e(t,ra),e(ra,ll),e(t,sl),e(t,na),e(na,il),e(t,cl),e(t,la),e(la,hl),e(t,dl),e(t,sa),e(sa,pl),e(t,ul),e(t,ia),e(ia,ca),e(ca,fl),e(t,vl),e(t,ha),e(ha,ml),e(t,wl),e(t,re),e(re,gl),e(re,da),e(da,bl),e(re,yl),e(t,El),e(t,pa),e(pa,_l),e(t,Sl),e(t,ua),e(ua,kl),e(t,Tl),e(t,fa),e(fa,Pl),e(t,Ol),e(t,va),e(va,Cl),e(t,xl),e(t,ma),e(ma,wa),e(wa,Al),e(t,Dl),e(t,Ce),e(Ce,jl),e(Ce,ga),e(ga,Ml),e(t,Il),e(t,ba),e(ba,Nl),e(t,Hl),e(t,ya),e(ya,Ea),e(Ea,Rl),e(t,Jl),e(t,O),e(O,Wl),e(O,_a),e(_a,xe),e(xe,Fl),e(O,Ll),e(O,Sa),e(Sa,Ae),e(Ae,$l),e(O,ql),e(O,ka),e(ka,De),e(De,Gl),e(O,Ul),e(t,Vl),e(t,ne),e(ne,zl),e(ne,je),e(je,Bl),e(ne,Yl),e(t,Kl),e(t,C),e(C,Xl),e(C,Me),e(Me,Zl),e(C,Ql),e(C,Ie),e(Ie,es),e(C,ts),e(C,Ne),e(Ne,as),e(C,os),e(t,rs),e(t,Ta),e(Ta,ns),e(t,ls),e(t,Pa),e(Pa,ss),e(t,is),e(t,Oa),e(Oa,cs),e(t,hs),e(t,Ca),e(Ca,ds),e(t,ps),e(t,xa),e(xa,us),e(t,fs),e(t,Aa),e(Aa,vs),e(t,ms),e(t,Da),e(Da,ws),e(t,gs),e(t,ja),e(ja,bs),e(t,ys),e(t,Ma),e(Ma,Es),e(t,_s),e(t,Ia),e(Ia,Ss),e(t,ks),e(t,Na),e(Na,Ts),e(t,Ps),e(t,Ha),e(Ha,Os),e(t,Cs),e(t,Ra),e(Ra,xs),e(t,As),e(t,Ja),e(Ja,Ds),e(t,js),e(t,Wa),e(Wa,Ms),e(t,Is),e(t,Fa),e(Fa,Ns),e(t,Hs),e(t,La),e(La,Rs),e(t,Js),e(t,$a),e($a,Ws),e(t,Fs),e(t,qa),e(qa,Ls),e(t,$s),e(t,Ga),e(Ga,qs),e(t,Gs),e(t,Ua),e(Ua,Us),e(t,Vs),e(t,Va),e(Va,zs),e(t,Bs),e(t,za),e(za,Ys),e(t,Ks),e(t,Ba),e(Ba,Xs),e(t,Zs),e(t,Ya),e(Ya,Qs),e(t,ei),e(t,Ka),e(Ka,ti),e(t,ai),e(t,Xa),e(Xa,oi),e(t,ri),e(t,Za),e(Za,ni),e(t,li),e(t,Qa),e(Qa,si),e(t,ii),e(t,eo),e(eo,ci),e(t,hi),e(t,to),e(to,di),e(t,pi),e(t,ao),e(ao,ui),e(t,fi),e(t,le),e(le,vi),e(le,He),e(He,mi),e(le,wi),e(t,gi),e(t,oo),e(oo,bi),e(t,yi),e(t,ro),e(ro,Ei),e(t,_i),e(t,se),e(se,Si),e(se,Re),e(Re,ki),e(se,Ti),e(t,Pi),e(t,no),e(no,Oi),e(t,Ci),e(t,j),e(j,xi),e(j,Je),e(Je,Ai),e(j,Di),e(j,We),e(We,ji),e(j,Mi),e(t,Ii),e(t,M),e(M,Ni),e(M,Fe),e(Fe,Hi),e(M,Ri),e(M,Le),e(Le,Ji),e(M,Wi),e(t,Fi),e(t,b),e(b,Li),e(b,$e),e($e,$i),e(b,qi),e(b,qe),e(qe,Gi),e(b,Ui),e(b,Ge),e(Ge,Vi),e(b,zi),e(b,Ue),e(Ue,Bi),e(b,Yi),e(b,Ve),e(Ve,Ki),e(b,Xi),e(t,Zi),e(t,lo),e(lo,Qi),e(t,ec),e(t,I),e(I,tc),e(I,ze),e(ze,ac),e(I,oc),e(I,Be),e(Be,rc),e(I,nc),e(t,lc),e(t,so),e(so,sc),e(t,ic),e(t,io),e(io,cc),e(t,hc),e(t,co),e(co,dc),e(t,pc),e(t,ho),e(ho,uc),e(t,fc),e(t,po),e(po,vc),e(t,mc),e(t,uo),e(uo,wc),e(t,gc),e(t,fo),e(fo,bc),e(t,yc),e(t,vo),e(vo,Ec),e(t,_c),e(t,mo),e(mo,Sc),e(t,kc),e(t,v),e(v,Tc),e(v,Ye),e(Ye,Pc),e(v,Oc),e(v,Ke),e(Ke,Cc),e(v,xc),e(v,Xe),e(Xe,Ac),e(v,Dc),e(v,Ze),e(Ze,jc),e(v,Mc),e(v,Qe),e(Qe,Ic),e(v,Nc),e(v,et),e(et,Hc),e(v,Rc),e(v,tt),e(tt,Jc),e(v,Wc),e(v,at),e(at,Fc),e(v,Lc),e(t,$c),e(t,wo),e(wo,qc),e(t,Gc),e(t,x),e(x,Uc),e(x,ot),e(ot,Vc),e(x,zc),e(x,rt),e(rt,Bc),e(x,Yc),e(x,nt),e(nt,Kc),e(x,Xc),e(t,Zc),e(t,go),e(go,Qc),e(t,eh),e(t,bo),e(bo,th),e(t,ah),e(t,A),e(A,oh),e(A,lt),e(lt,rh),e(A,nh),e(A,st),e(st,lh),e(A,sh),e(A,it),e(it,ih),e(A,ch),e(t,hh),e(t,yo),e(yo,dh),e(t,ph),e(t,N),e(N,uh),e(N,ct),e(ct,fh),e(N,vh),e(N,ht),e(ht,mh),e(N,wh),e(t,gh),e(t,Eo),e(Eo,bh),e(t,yh),e(t,H),e(H,Eh),e(H,dt),e(dt,_h),e(H,Sh),e(H,pt),e(pt,kh),e(H,Th),e(t,Ph),e(t,_o),e(_o,Oh),e(t,Ch),e(t,ie),e(ie,xh),e(ie,ut),e(ut,Ah),e(ie,Dh),e(t,jh),e(t,ce),e(ce,Mh),e(ce,ft),e(ft,Ih),e(ce,Nh),e(t,Hh),e(t,So),e(So,Rh),e(t,Jh),e(t,he),e(he,Wh),e(he,ko),e(ko,Fh),e(he,Lh),e(t,$h),e(t,de),e(de,qh),e(de,vt),e(vt,Gh),e(de,Uh),e(t,Vh),e(t,To),e(To,zh),e(t,Bh),e(t,Po),e(Po,Yh),e(t,Kh),e(t,Oo),e(Oo,Xh),e(t,Zh),e(t,pe),e(pe,Qh),e(pe,mt),e(mt,ed),e(pe,td),e(t,ad),e(t,ue),e(ue,od),e(ue,wt),e(wt,rd),e(ue,nd),e(t,ld),e(t,Co),e(Co,sd),e(t,id),e(t,xo),e(xo,cd),e(t,hd),e(t,Ao),e(Ao,dd),e(t,pd),e(t,Do),e(Do,ud),e(t,fd),e(t,jo),e(jo,vd),e(t,md),e(t,Mo),e(Mo,wd)},d(p){p&&n(u),p&&n(f),p&&n(w),p&&n(Io),p&&n(W),p&&n(No),p&&n(F),p&&n(Ho),p&&n(t)}}}function nv(fe){let u,E;const y=[fe[0],Gf];let U={$$slots:{default:[rv]},$$scope:{ctx:fe}};for(let f=0;f<y.length;f+=1)U=Ed(U,y[f]);return u=new av({props:U}),{c(){Bf(u.$$.fragment)},l(f){Yf(u.$$.fragment,f)},m(f,w){Kf(u,f,w),E=!0},p(f,[w]){const J=w&1?Xf(y,[w&1&&Lf(f[0]),w&0&&Lf(Gf)]):{};w&2&&(J.$$scope={dirty:w,ctx:f}),u.$set(J)},i(f){E||(Zf(u.$$.fragment,f),E=!0)},o(f){Qf(u.$$.fragment,f),E=!1},d(f){ev(u,f)}}}const Gf={title:"Looking into the Svelte Compiler",occasion:"CityJS Conf 2020",date:"2020-09-14",label:"talk",layout:"talk",description:"Recorded talkCityJS Conference 2020MMT Tech Meetup - Sept 2020Slides[Link to slides] (Left arrow and right arrow to navigate)ScriptModern web frameworks allow us to describe our UI declaratively, as a function of state, of the application. ...",tableOfContents:[{link:"recorded-talk",title:"Recorded talk",nested:[{link:"cityjs-conference-2020",title:"CityJS Conference 2020"},{link:"mmt-tech-meetup-sept-2020",title:"MMT Tech Meetup - Sept 2020"}]},{link:"slides",title:"Slides"},{link:"script",title:"Script"}]};function lv(fe,u,E){return tv("blog",{image:ov}),fe.$$set=y=>{E(0,u=Ed(Ed({},u),$f(y)))},u=$f(u),[u]}class pv extends Uf{constructor(u){super();Vf(this,u,lv,nv,zf,{})}}export{pv as default,Gf as metadata};
