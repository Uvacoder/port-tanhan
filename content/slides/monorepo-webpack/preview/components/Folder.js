/* generated by Svelte v3.24.0 */
import {
	HtmlTag,
	SvelteComponent,
	add_flush_callback,
	append,
	attr,
	bind,
	binding_callbacks,
	check_outros,
	create_component,
	destroy_component,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	noop,
	outro_and_destroy_block,
	safe_not_equal,
	set_data,
	space,
	text,
	toggle_class,
	transition_in,
	transition_out,
	update_keyed_each
} from "/svelte/internal.js";

function add_css() {
	var style = element("style");
	style.id = "svelte-n0e9zu-style";
	style.textContent = "div.svelte-n0e9zu{font-family:monospace;user-select:none}.highlighted.svelte-n0e9zu{color:red}.file.svelte-n0e9zu{cursor:pointer}.child.svelte-n0e9zu{display:none}.child.expand.svelte-n0e9zu{display:contents}.comment.svelte-n0e9zu{color:gray;font-style:italic}.info.svelte-n0e9zu{white-space:break-spaces;word-break:break-word}";
	append(document.head, style);
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i].name;
	child_ctx[10] = list[i].type;
	child_ctx[11] = list[i].children;
	child_ctx[12] = list[i].pathname;
	child_ctx[13] = list[i].link;
	child_ctx[14] = list[i].linkRelative;
	child_ctx[15] = list[i].comment;
	child_ctx[17] = i;
	return child_ctx;
}

// (25:2) {#if highlightedPath && !level}
function create_if_block_6(ctx) {
	let div;
	let t0;

	let t1_value = (Array.isArray(/*highlightedPath*/ ctx[0])
	? /*highlightedPath*/ ctx[0][0]
	: /*highlightedPath*/ ctx[0]) + "";

	let t1;

	return {
		c() {
			div = element("div");
			t0 = text("Selected: ");
			t1 = text(t1_value);
			attr(div, "class", "info svelte-n0e9zu");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t0);
			append(div, t1);
		},
		p(ctx, dirty) {
			if (dirty & /*highlightedPath*/ 1 && t1_value !== (t1_value = (Array.isArray(/*highlightedPath*/ ctx[0])
			? /*highlightedPath*/ ctx[0][0]
			: /*highlightedPath*/ ctx[0]) + "")) set_data(t1, t1_value);
		},
		d(detaching) {
			if (detaching) detach(div);
		}
	};
}

// (35:6) {:else}
function create_else_block_1(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "├─";
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (33:44) 
function create_if_block_5(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "└─";
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (31:19) {#if level === '' && folder.length === 1}
function create_if_block_4(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			span.textContent = "├─";
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (52:6) {:else}
function create_else_block(ctx) {
	let span;
	let t_value = /*name*/ ctx[9] + "";
	let t;
	let if_block0_anchor;
	let mounted;
	let dispose;
	let if_block0 = /*link*/ ctx[13] && create_if_block_3(ctx);
	let if_block1 = /*comment*/ ctx[15] && create_if_block_2(ctx);

	function click_handler_1(...args) {
		return /*click_handler_1*/ ctx[8](/*pathname*/ ctx[12], /*link*/ ctx[13], ...args);
	}

	return {
		c() {
			span = element("span");
			t = text(t_value);
			if (if_block0) if_block0.c();
			if_block0_anchor = empty();
			if (if_block1) if_block1.c();
			attr(span, "class", "file svelte-n0e9zu");
			toggle_class(span, "highlighted", shouldHighlight(/*highlightedPath*/ ctx[0], /*pathname*/ ctx[12]));
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
			if (if_block0) if_block0.m(span, null);
			append(span, if_block0_anchor);
			if (if_block1) if_block1.m(span, null);

			if (!mounted) {
				dispose = listen(span, "click", click_handler_1);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*folder*/ 2 && t_value !== (t_value = /*name*/ ctx[9] + "")) set_data(t, t_value);

			if (/*link*/ ctx[13]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					if_block0.m(span, if_block0_anchor);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*comment*/ ctx[15]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					if_block1.m(span, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*shouldHighlight, highlightedPath, folder*/ 3) {
				toggle_class(span, "highlighted", shouldHighlight(/*highlightedPath*/ ctx[0], /*pathname*/ ctx[12]));
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(span);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};
}

// (38:6) {#if type === 'D'}
function create_if_block(ctx) {
	let span;
	let t0_value = /*name*/ ctx[9] + "";
	let t0;
	let t1;
	let div;
	let folder_1;
	let updating_highlightedPath;
	let current;
	let mounted;
	let dispose;
	let if_block = /*comment*/ ctx[15] && create_if_block_1(ctx);

	function click_handler(...args) {
		return /*click_handler*/ ctx[6](/*index*/ ctx[17], ...args);
	}

	function folder_1_highlightedPath_binding(value) {
		/*folder_1_highlightedPath_binding*/ ctx[7].call(null, value);
	}

	let folder_1_props = {
		folder: /*children*/ ctx[11],
		level: /*level*/ ctx[2] + `${/*index*/ ctx[17] === /*folder*/ ctx[1].length - 1
		? /*SPACE*/ ctx[4] + /*SPACE*/ ctx[4] + /*SPACE*/ ctx[4]
		: "│" + /*SPACE*/ ctx[4] + /*SPACE*/ ctx[4]}`,
		path: /*pathname*/ ctx[12]
	};

	if (/*highlightedPath*/ ctx[0] !== void 0) {
		folder_1_props.highlightedPath = /*highlightedPath*/ ctx[0];
	}

	folder_1 = new Folder({ props: folder_1_props });
	binding_callbacks.push(() => bind(folder_1, "highlightedPath", folder_1_highlightedPath_binding));

	return {
		c() {
			span = element("span");
			t0 = text(t0_value);
			if (if_block) if_block.c();
			t1 = space();
			div = element("div");
			create_component(folder_1.$$.fragment);
			attr(span, "class", "file svelte-n0e9zu");
			toggle_class(span, "highlighted", shouldHighlight(/*highlightedPath*/ ctx[0], /*pathname*/ ctx[12]));
			attr(div, "class", "child svelte-n0e9zu");
			toggle_class(div, "expand", /*expand*/ ctx[3][/*index*/ ctx[17]]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			if (if_block) if_block.m(span, null);
			insert(target, t1, anchor);
			insert(target, div, anchor);
			mount_component(folder_1, div, null);
			current = true;

			if (!mounted) {
				dispose = listen(span, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if ((!current || dirty & /*folder*/ 2) && t0_value !== (t0_value = /*name*/ ctx[9] + "")) set_data(t0, t0_value);

			if (/*comment*/ ctx[15]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(span, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*shouldHighlight, highlightedPath, folder*/ 3) {
				toggle_class(span, "highlighted", shouldHighlight(/*highlightedPath*/ ctx[0], /*pathname*/ ctx[12]));
			}

			const folder_1_changes = {};
			if (dirty & /*folder*/ 2) folder_1_changes.folder = /*children*/ ctx[11];

			if (dirty & /*level, folder*/ 6) folder_1_changes.level = /*level*/ ctx[2] + `${/*index*/ ctx[17] === /*folder*/ ctx[1].length - 1
			? /*SPACE*/ ctx[4] + /*SPACE*/ ctx[4] + /*SPACE*/ ctx[4]
			: "│" + /*SPACE*/ ctx[4] + /*SPACE*/ ctx[4]}`;

			if (dirty & /*folder*/ 2) folder_1_changes.path = /*pathname*/ ctx[12];

			if (!updating_highlightedPath && dirty & /*highlightedPath*/ 1) {
				updating_highlightedPath = true;
				folder_1_changes.highlightedPath = /*highlightedPath*/ ctx[0];
				add_flush_callback(() => updating_highlightedPath = false);
			}

			folder_1.$set(folder_1_changes);

			if (dirty & /*expand, folder*/ 10) {
				toggle_class(div, "expand", /*expand*/ ctx[3][/*index*/ ctx[17]]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(folder_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(folder_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			if (if_block) if_block.d();
			if (detaching) detach(t1);
			if (detaching) detach(div);
			destroy_component(folder_1);
			mounted = false;
			dispose();
		}
	};
}

// (66:19) {#if link}
function create_if_block_3(ctx) {
	let t_value = ` --> ${/*linkRelative*/ ctx[14]}` + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*folder*/ 2 && t_value !== (t_value = ` --> ${/*linkRelative*/ ctx[14]}` + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (66:58) {#if comment}
function create_if_block_2(ctx) {
	let span;
	let t_value = /*comment*/ ctx[15] + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
			attr(span, "class", "comment svelte-n0e9zu");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*folder*/ 2 && t_value !== (t_value = /*comment*/ ctx[15] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (43:15) {#if comment}
function create_if_block_1(ctx) {
	let span;
	let t_value = /*comment*/ ctx[15] + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
			attr(span, "class", "comment svelte-n0e9zu");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*folder*/ 2 && t_value !== (t_value = /*comment*/ ctx[15] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
		}
	};
}

// (29:2) {#each folder as { name, type, children, pathname, link, linkRelative, comment }
function create_each_block(key_1, ctx) {
	let div;
	let html_tag;
	let html_anchor;
	let t0;
	let current_block_type_index;
	let if_block1;
	let t1;
	let current;

	function select_block_type(ctx, dirty) {
		if (/*level*/ ctx[2] === "" && /*folder*/ ctx[1].length === 1) return create_if_block_4;
		if (/*index*/ ctx[17] === /*folder*/ ctx[1].length - 1) return create_if_block_5;
		return create_else_block_1;
	}

	let current_block_type = select_block_type(ctx, -1);
	let if_block0 = current_block_type(ctx);
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*type*/ ctx[10] === "D") return 0;
		return 1;
	}

	current_block_type_index = select_block_type_1(ctx, -1);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		key: key_1,
		first: null,
		c() {
			div = element("div");
			html_anchor = empty();
			if_block0.c();
			t0 = space();
			if_block1.c();
			t1 = space();
			html_tag = new HtmlTag(html_anchor);
			attr(div, "class", "svelte-n0e9zu");
			this.first = div;
		},
		m(target, anchor) {
			insert(target, div, anchor);
			html_tag.m(/*level*/ ctx[2], div);
			append(div, html_anchor);
			if_block0.m(div, null);
			append(div, t0);
			if_blocks[current_block_type_index].m(div, null);
			append(div, t1);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*level*/ 4) html_tag.p(/*level*/ ctx[2]);

			if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(div, t0);
				}
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				}

				transition_in(if_block1, 1);
				if_block1.m(div, t1);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_block0.d();
			if_blocks[current_block_type_index].d();
		}
	};
}

function create_fragment(ctx) {
	let div;
	let t;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let current;
	let if_block = /*highlightedPath*/ ctx[0] && !/*level*/ ctx[2] && create_if_block_6(ctx);
	let each_value = /*folder*/ ctx[1];
	const get_key = ctx => /*name*/ ctx[9];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "svelte-n0e9zu");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (/*highlightedPath*/ ctx[0] && !/*level*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_6(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*expand, folder, level, SPACE, highlightedPath, shouldHighlight*/ 31) {
				const each_value = /*folder*/ ctx[1];
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if (if_block) if_block.d();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

function shouldHighlight(highlightedPath, path) {
	if (Array.isArray(highlightedPath)) {
		for (const item of highlightedPath) {
			if (item === path || item.startsWith(path + "/")) {
				return true;
			}
		}

		return false;
	}

	return highlightedPath === path || highlightedPath.startsWith(path + "/");
}

function instance($$self, $$props, $$invalidate) {
	let { folder = [] } = $$props;
	let { path = "" } = $$props;
	let { highlightedPath = "" } = $$props;
	let { level = "" } = $$props;
	const SPACE = `<span style='color: transparent;'>@</span>`;
	const click_handler = index => $$invalidate(3, expand[index] = !expand[index], expand);

	function folder_1_highlightedPath_binding(value) {
		highlightedPath = value;
		$$invalidate(0, highlightedPath);
	}

	const click_handler_1 = (pathname, link) => {
		let target = pathname;

		if (highlightedPath === target || highlightedPath.has?.(target)) $$invalidate(0, highlightedPath = ""); else {
			if (link) {
				$$invalidate(0, highlightedPath = [link, target]);
			} else {
				$$invalidate(0, highlightedPath = target);
			}
		}
	};

	$$self.$set = $$props => {
		if ("folder" in $$props) $$invalidate(1, folder = $$props.folder);
		if ("path" in $$props) $$invalidate(5, path = $$props.path);
		if ("highlightedPath" in $$props) $$invalidate(0, highlightedPath = $$props.highlightedPath);
		if ("level" in $$props) $$invalidate(2, level = $$props.level);
	};

	let expand;

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*folder*/ 2) {
			$: $$invalidate(3, expand = folder.map(i => true));
		}
	};

	return [
		highlightedPath,
		folder,
		level,
		expand,
		SPACE,
		path,
		click_handler,
		folder_1_highlightedPath_binding,
		click_handler_1
	];
}

class Folder extends SvelteComponent {
	constructor(options) {
		super();
		if (!document.getElementById("svelte-n0e9zu-style")) add_css();

		init(this, options, instance, create_fragment, safe_not_equal, {
			folder: 1,
			path: 5,
			highlightedPath: 0,
			level: 2
		});
	}
}

export default Folder;