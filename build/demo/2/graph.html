<!DOCTYPE html>
<meta charset="utf-8">
<head>
<style>
.graph {
	width: 100%;
	height: 100%;
}
.link {
  stroke: #000;
}

.node {
  stroke: #fff;
}

.node.source {
	fill: #00f;
}
.node.mass {
	stroke: #f00;
	stroke-width: 3;
}
.node.selected {
	fill: #0f0;
}
.info{
	width: 400px;
    height: 200px;
    position: absolute;
    bottom: 10px;
    right: 10px;
    padding: 10px;
    background: white;
    background-color: white;
    border: black 1px solid;
}
</style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.16/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script type="text/javascript">
	var container;
	function zoomed() {
		container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
	}
	function isUndefined(a){
		return (typeof a == "undefined");
	}
	var node;
$(function(){
		$("body").height($(window).height());
		var width = $(".graph").width(),
		height = 600;

		zoom = d3.behavior.zoom()
			.scaleExtent([0.01, 20])
			.on("zoom", zoomed);

		var svg = d3.select(".graph").append("svg")
			.attr("width", "100%")
			.attr("height", "100%")
			.append("svg:g")
			.call(zoom);

		container = svg.append("svg:g");

		var background = container.append("rect")
				.classed("background", true)
				.attr("x",-50000)
				.attr("y",-50000)
				.attr("width",100000)
				.attr("height",100000)
				.attr("fill", "white")
				.attr("opacity",0);


		var force = d3.layout.force()
			.size([width, height]);

		d3.csv("network.csv", function(links) {
		  var nodesByName = {};

		// Create nodes for each unique source and target.
		links.forEach(function(link) {
			link.source = nodeByName(link.source);
			link.target = nodeByName(link.target);
			link.size = +link.size;
			if(typeof link.source.size == "undefined"){
				link.source.size = link.size;
			}else{
				link.source.size += link.size;
			}
			addLink(link.source, link);
			addLink(link.target, link);
		});

		// Extract the array of nodes from the map by name.
		var nodes = d3.values(nodesByName);

			  // Start the force layout.
		force.nodes(nodes)
			.links(links)
			.on("tick", tick)
// 			.linkDistance(function(link,index){
// 				return link.size;
// 			})
			.start();

		// Create the link lines.
		var link = container.selectAll(".link")
			.data(links)
		.enter().append("line")
			.attr("class", "link")
			.on("click", function(d){
				var m = d.source.name + "-->" + d.target.name + "\n Size: " + d.size;
				alert(m);
			});

		// Create the node circles.
		node = container.selectAll(".node")
			.data(nodes)
		.enter().append("circle")
			.attr("class", "node")
			.attr("r", function(d){
				a = 3 + ((isUndefined(d.size))? 0: (Math.log(d.size)/Math.log(10)))/2;
				return a;
			})
			.classed("source", function(d){
				return !isUndefined(d.size);
			})
			.classed("mass", function(d){
				return d.link.length > 50;
			})
			.call(force.drag)
			.on("click", function(d){
				node.classed("selected", false)
					.each(function(e){
						e.clusterSelected = false;
					});
				var selection = selectCluster(d);
				var filter = node.filter(function(e){
					return selection.indexOf(e) > -1;
				});
				filter.classed("selected", true);
// 				var m = d.name + "\nTotal Size: " + (isUndefined(d.size)? 0: d.size) +
// 					"\nNumber Of Links: " + d.link.length;
// 				alert(m);
			});

		//zoom out
		container.call(zoom.translate([450,200]).scale(0.25).event);

	  function tick() {
		link.attr("x1", function(d) { return d.source.x; })
			.attr("y1", function(d) { return d.source.y; })
			.attr("x2", function(d) { return d.target.x; })
			.attr("y2", function(d) { return d.target.y; });

		node.attr("cx", function(d) { return d.x; })
			.attr("cy", function(d) { return d.y; });
	  }

		function addLink(node, link){
			if(typeof node.link == "undefined"){
				node.link = [link];
			}else{
				node.link.push(link);
			}
		}
	  function nodeByName(name) {
		return nodesByName[name] || (nodesByName[name] = {name: name});
	  }
	  function selectCluster(node){
	  		var selection = [];
	  		selectClusterByNode(node, selection);
	  		return selection;
	  }
	  function selectClusterByNode(node, selection){
	  	if(typeof node.clusterSelected == "undefined" || !node.clusterSelected){
	  		node.clusterSelected = true;
	  		selection.push(node);
			node.link.forEach(function(e){
				selectClusterByNode(e.source, selection);
				selectClusterByNode(e.target, selection);
			});
		}
	  }
	});
});
</script>
<div class="graph"></div>
<div class="info">
	This network graph is plotted based on the traffic data collected from the research. <br />
	The node in the graph denotes an ip address in the traffic. The edge denotes a traffic between the ip address. <br />
	Blue-colored node is the source, and black-colored node is the destination. In other words, for each pair of node connected by an edge, denotes a traffic starting from the blue colored node to the black colored node. <br />
	The size of the node gives us insights of the relative traffic going in and coming from the node. <br />
</div>
</body>
</html>
